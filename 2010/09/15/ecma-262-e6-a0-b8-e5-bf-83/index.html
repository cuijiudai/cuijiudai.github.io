<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ECMA-262 核心 | 美拓blog | 做个有趣的人</title>

  
  <meta name="author" content="独孤逸辰">
  

  
  <meta name="description" content="互联网开发者，金融爱好者,关注农业民生。">
  

  
  
  <meta name="keywords" content="ECMA-262">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="ECMA-262 核心"/>

  <meta property="og:site_name" content="美拓blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="美拓blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">美拓blog</a>
    </h1>
    <p class="site-description">做个有趣的人</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/about">About</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article >

  
    
    <h3 class="article-title"><span>ECMA-262 核心</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2010/09/15/ecma-262-e6-a0-b8-e5-bf-83/" rel="bookmark">
        <time class="entry-date published" datetime="2010-09-14T16:49:47.000Z">
          2010-09-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>翻译了半天发现早已有人翻译了，前四章是本人翻译的，翻译的不怎么样，第五章以后出自 remember2015的<a href="http://remember2015.info/blog/?p=141" target="_blank" rel="external">[译] JavaScript核心指南(JavaScript Core)</a></p>
<p><pre><br>An object — 对象,A prototype chain — 原型链,Constructor — 构造器,Scope chain — 作用域链<br>execution context stack – 执行上下文栈<br></pre></p>
<div class="entrytext"><br><style type="text/css" media="screen"><br>.definition {<br>    border-left:2px solid #284A66;<br>    color:#444444;<br>    font-size:1em;<br>    margin:0 30px;<br>    padding-left:10px;<br>    padding-right:10px;<br>}<br></style><br><div class="ds-toc"><br><br>1.  <a href="#an-object">对象(An Object)</a>2.  <a href="#a-prototype-chain">原型链(A Prototype Chain)</a>3.  <a href="#constructor">构造函数(Constructor)</a>4.  <a href="#execution-context-stack">执行上下文栈(Execution Context Stack)</a>5.  <a href="#execution-context">执行上下文(Execution Context)</a>6.  <a href="#variable-object">变量对象(Variable Object)</a>7.  <a href="#activation-object">活动对象(Activation Object)</a>8.  <a href="#scope-chain">作用域链(Scope Chain)</a>9.  <a href="#closures">闭包(Closures)</a>10.  <a href="#this-value">this指针(This Value)</a>11.  <a href="#conclusion">总结(Conclusion)</a><br></div><br><a id="more"></a><br>本文是对学习“<a href="http://dmitrysoshnikov.com/tag/ecma-262-3/" target="_blank" rel="external">ECMA-262-3 in detail</a>”系列的一个总结和回顾，本文每个部分都有对<abbr title="ECMAScript 3rd edition">ES3</abbr>系列相应章节的链接，如果你有兴趣可以深入阅读一下。<br><br>我们从ECMAScript基础之一<em>object</em>的概念入手。<br><br>### <a href="#an-object">Object</a><br><br>通过 <em>objects</em> ECMAScript成为了一个高度抽象、基于对象的语言，对于原始类型，但是当需要的时候它们也可以转化为object。<br><br>object 是一个<code>属性的集合</code>和一个<code>prototype</code>对象，prototype可以是一个object或者<code>null</code><br><br>在下面的描述中我们将看一下object的基本外形（figure），object的 prototype 可以使用内部的 [[Prototype]] 属性引用到，然而在图中我们用<strong>&lt;internal-property&gt;</strong> 符号（notation）来表示内部属性，原型对象可以这样表示： <code>__proto__</code>（这是一个非标准的，但在某些引擎中如：SpiderMonkey 这是一个真实的实现）.<br><br>看例子:<br>[code=”js”]<br>    var foo = {<br>        x: 10,<br>        y: 20<br>    };<br>[/code]<br><br>foo拥有两个显式的属性和一个隐式的可以引用到 ‘foo’的 prototype 的<strong>proto</strong> 属性。<br><br><img src="http://blog.meituo.net/wp-content/uploads/ecmascript_core/basic-object.png" alt="Figure 1\. A basic object with a prototype." title="Figure 1\. A basic object with a prototype."><br><br>这些prototype 有什么用？ 让我们那看看 <code>原型链</code>的概念来回答这个问题。<br><br>### <a href="#a-prototype-chain">原型链</a><br><br>Prototype对象也是简单的对象，也拥有自己的属性。如果一个prototype 拥有一个非null 的 prototype ，这称为<em>原型链</em>.<br><br>原型链是一个用来实现<em>继承</em>和<em>分享属性</em>的<em>有限</em>对象链<br><br>设想这种情况，我们有两个对象，他们仅仅有一些小的不同其他大部分是相同的，显然，对于一个良好设计的系统，我们希望重用这些相似的函数或者代码，而不是重复的在每个对象重新定义或者书写一次。在基于类（class-based）的系统中,这种<code>代码重用</code>形式称为<em>基于类的继承</em>—将相似的功能行放到 类A 中，然后让 类B 和 类C 继承 A ，同时自己额外拥有小部分的改变。<br><br>ECMAScript 没用类（class）的概念，但是 代码重用的设计并没有很大的不同（虽然，在某些方面它比类继承更加的灵活），它是通过 <em>原型链</em>实现的。这种继承方法称为<em>基于委托的继承(delegation based inheritance)</em>(或者，更接近ECMAScript，基于原型的继承)。<br><br>和例子中的类’A’,’B’和’C’相似，在ECMAScript中创建 对象 ‘a’,’b’和’c’ ，这样 对象 ‘ a ‘ 保存 ‘ b ‘ 和’c’ 相同的部分，  ‘ b ‘ 和’c’  仅保存他们另外的属性和方法。<br>[code=’js’]<br>var a = {<br>  x: 10,<br>  calculate: function (z) {<br>    return this.x + this.y + z<br>  }<br>};<br><br>var b = {<br>  y: 20,<br>  <strong>proto</strong>: a<br>};<br><br>var c = {<br>  y: 30,<br>  <strong>proto</strong>: a<br>};<br><br>// call the inherited method<br>b.calculate(30); // 60<br>c.calculate(40); // 80<br><br>[/code]<br><br>很简单吧？ 我们看到对象 ‘b ‘  和 ‘ c ‘ 能够使用在对象’a’ 中定义的’ calculate ‘方法，这是通过原型链实现的，规则很简单，如果一个属性或者方法在对象本身找不到（i.e. 对象没有这样<em>自己的（own）属性</em>）然后就会试图从原型链中寻找这个属性或方法，如果这个属性在prototype中没有找到，然后就会寻找 prototype的 prototype，就这样，直到整个原型链（其实和基于类的继承完全相同，当要获取一个继承的<em>方法</em> — 这里我们寻找的是<em>类链(class chain)</em>），第一个找到同名 属性/方法会被使用，这样 这个找到的属性被称为<em> 继承的</em>属性。如果在整个原型链中没有找到这个属性，那么就会返回<em>undefined</em> 。<br><br>注意,在使用继承方法时，在找到的方法里指<em>this</em> 的是<em>原始的(original)</em>的对象，而不是 那个prototype对象。例如：在上面的例子里 “ this.y “ 是从  ‘ b ‘和 ‘ c ‘获得的，而不是从 ‘a’ 。 而 ‘ this.x ‘就是从’a’ 获得的，也是通过原型链机制。<br><br>如果一个对象没有显式的声明prototype，那么默认的 ‘ <strong>proto</strong> ‘ 是 <em>Object.prototype</em>，Object  “Object.prototype” 自己也有一个’ <strong>proto</strong>‘ ,这是链的<em>终点</em>,值为<em>null</em>。<br><br>下一个图显示了对象a,b,c的继承层次机构.<br><img src="http://blog.meituo.net/wp-content/uploads/ecmascript_core/prototype-chain.png" alt="Figure 2\. A prototype chain." title="Figure 2\. A prototype chain."><br><br>经常我们需要对象拥有 <em>相同的或者相似的结构</em>,(i.e.相同的属性) 但不同的<em>属性值</em>。这样的话我们或许需要一个通过<em>特定的模式(specified patter)</em>生成对象的<em>constructor</em> 。<br><br>### <a href="#constructor">Constructor</a><br><br>除了以特定的模式创建对象，<em>constructor</em> 函数做了另一件有用的事——为新 创建的对象<em>自动设置一个prototype对象</em>。这个prototype 对象存储在<em>ConstructorFunction.prototype</em>属性中。<br><br>E.g，我们可以重写前面的例子，使用constructor 来创建’b’,’c’. 这样，a对象相当于 ’ Foo.prototype‘ 。<br>[code=’js’]<br>// a constructor function<br>function Foo(y) {<br>  // which may create objects<br>  // by specified pattern: they have after<br>  // creation own “y” property<br>  this.y = y;<br>}<br><br>// also “Foo.prototype” stores reference<br>// to the prototype of newly created objects,<br>// so we may use it to define shared/inherited<br>// properties or methods, so the same as in<br>// previous example we have:<br><br>// inherited property “x”<br>Foo.prototype.x = 10;<br><br>// and inherited method “calculate”<br>Foo.prototype.calculate = function (z) {<br>  this.x + this.y + z;<br>};<br><br>// now create our “b” and “c”<br>// objects using “pattern” Foo<br>var b = new Foo(20);<br>var c = new Foo(30);<br><br>// call the inherited method<br>b.calculate(30); // 60<br>c.calculate(40); // 80<br><br>// let’s show that we reference<br>// properties we expect<br><br>console.log(<br><br>  b.<strong>proto</strong> === Foo.prototype, // true<br>  c.<strong>proto</strong> === Foo.prototype, // true<br><br>  // also “Foo.prototype” automatically creates<br>  // a special property “constructor”, which is a<br>  // reference to the constructor function itself;<br>  // instances “b” and “c” may found it via<br>  // delegation and use to check their constructor<br><br>  b.constructor === Foo, // true<br>  c.constructor === Foo, // true<br>  Foo.prototype.constructor === Foo // true<br><br>  b.calculate === b.<strong>proto</strong>.calculate, // true<br>  b.<strong>proto</strong>.calculate === Foo.prototype.calculate // true<br><br>);<br><br>[/code]<br>This code may be presented as the following relationship:<br>这些代码可以用以下关系呈现<br><img src="http://blog.meituo.net/wp-content/uploads/ecmascript_core/constructor-proto-chain.png" alt="Figure 3\. A constructor and objects relationship." title="Figure 3\. A constructor and objects relationship."><br><br>这个图再次显示了每个对象都有一个prototype，构造函数 ’Foo‘ 也有它自己的<strong>proto</strong> ，其值为 ‘Function.prototype ‘ ，通过它的<strong>proto</strong> 属性最终引用到 Object.prototype ,这样，’Foo.prototype’ 仅仅是 ’Foo‘的 一个显式属性。<br><br>正式的， 如果考虑到“classification”的概念 (我们刚才 定义（classified）了这个新的独立的对象— Foo)，constructor 函数和原型对象的组合可以称为“class”。 实际上，e.g. Python 的 “first-class”动态类有完全相同的 属性/方法 的实现。 从这个观点看， Python类是ECMAScript中使用的基于委托继承的语法糖（syntactic sugar）。<br><br>关于这个主题可以在ES 3 系列的第七章中找到，其中有两部分: <a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-1-oop-general-theory/" target="_blank" rel="external">Chapter 7.1. OOP. The general theory</a>,  那里您将发现各种各样的OOP范例的描述和形式及他们的与ECMAScript 的比较,<a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/" target="_blank" rel="external">Chapter 7.2. OOP. ECMAScript implementation</a>,全身心的投入到ECMAScript的OOP 吧<br><br>现在我们了解了基本的对象，让我们看看在ECMAScript 中 <em>runtime program execution</em> 是如何实行的，这称为  <em>执行上下文栈（execution context stack）</em> ,每个抽象的元素都可以用对象表示，是的，ECMAScript 几乎处处都是表现为一个对象。<br><br>### <a href="#execution-context-stack">执行作用域栈</a><br><br>有三种ECMAScript 代码：<em>全局</em>代码， <em>函数</em>代码 和 <em>eval</em>代码，每一种代码都他的执行上下文中执行，全局上下文只有一个，但可以有多个函数实例或<em>eval</em>执行上下文。每次调用函数就进入到了函数的执行上下文，并执行函数代码的类型。每次调用<em>eval</em> 就进入了<em>eval</em>的执行上下文并执行其代码。<br><br>注意：一个函数可以创建无限个上下文，因为每次调用（即使是递归）函数产生一个拥有新的上下文状态的上下文。<br>[code=’js’]<br>function foo(bar) {}<br><br>// call the same function,<br>// generate three different<br>// contexts in each call, with<br>// different context state (e.g. value<br>// of the “bar” argument)<br><br>foo(10);<br>foo(20);<br>foo(30);<br><br>[/code]<br><br>执行上下文可以激活另一个上下文，e.g. 函数调用另一个函数（或者全局上下文调用全局函数）等等，逻辑上，这将作为栈来执行，称为执行上下文栈。<br><br>激活另一个上下文的上下文称为 <em>caller</em>,那个被激活的上下文称为<em>callee</em>.callee 同时可以是caller（e.g. 一个被全局上下文调用的函数调用某些内部函数）<br><br>当一个caller激活（调用）一个callee,caller 挂起它的执行并将控制权交给callee，callee被推入栈中成为一个正在运行（激活）的执行上下文，当callee的上下文结束，它将控制权返还给caller,caller 的上下文将继续执行（当然有可能激活另一个上下文）直到结束，等等。callee 或者<em>返回</em>或者因异常退出，一个不能被接住的异常可能会跳出（从栈中弹出）一个或多个执行上下文。<br><br>I.e 所有的ECMAScript <em>程序执行(program runtime)</em> 都以<em>执行上下文（EC）栈</em>呈现。栈的顶部是<em>激活</em>的上下文。<br><br><img src="http://blog.meituo.net/wp-content/uploads/ecmascript_core/ec-stack.png" alt="Figure 4\. An execution context stack." title="Figure 4\. An execution context stack."><br><br>当程序开始执行，就进入了一个<em>全局执行上下文</em>,它是栈的底部也是栈的第一个元素。然后全局代码提供了一些初始化，创建必需的对象和函数，在全局上下文的执行期间，它可以激活其他一些（已经创建的）函数并进入这个函数的执行上下文将新的元素推入栈中，等等。当初始化完成，执行系统就等待<em>事件</em>触发(e.g 用户点击)，这些事件将激活某些函数并进入一个新的执行上下文。<br><br>在下一个图中，某些函数上下文 作为‘EC1’ ,全局上下文作为 ‘Global EC’,当从全局上下文进入或者退出’EC 1’，栈有以下的更改过程 :<br><br><img src="http://blog.meituo.net/wp-content/uploads/ecmascript_core/ec-stack-changes.png" alt="Figure 5\. An execution context stack changes." title="Figure 5\. An execution context stack changes."><br><br>这是真实的存在的,ECMAScript运行系统就是这样管理代码的执行。<br><br>关于ECMAScript执行上下文更多的信息可以在这里找到 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="external">Chapter 1. Execution context</a>.<br><br>正如我们所说，栈中的每一个执行上下文都表现为一个对象，让我们看看它的结构和上下文执行它的代码所需要的<em>状态(state)</em><br><br>### <a id="execution-context">五、执行上下文(Execution Context)</a><br><br>执行上下文可以抽象为一个简单的对象。每个上下文包含一系列属性(我们称之为 <em>上下文状态(context’s state) </em>) 用以跟踪相关代码的执行过程。下图展示了上下文的结构：<br><br><img src="http://blog.meituo.net/wp-content/uploads/ecmascript_core/execution-context.png" alt="Figure 6\. An execution context structure." title="Figure 6\. An execution context structure."><br><br>图 6. 上下文结构<br><br>除了这3个所需要的属性(<em>变量对象(variable object)，<strong>this指针(this value)，</strong>作用域链(scope chain) </em>)，执行上下文根据具体实现还可以具有任意额外属性。<br><br>接着，让我们仔细说明上下文的重要属性。<br><br>### <a id="variable-object">六、变量对象(Variable Object)</a><br><br>&gt; <em>变量对象(variable object)</em> 是与执行上下文相关的 <em>数据作用域(scope of data) </em>。它是与上下文关联的特殊对象，用于存储被定义在上下文中的 <em>变量(variables)</em> 和 <em>函数声明(function declarations) </em>。<br><br>请注意，变量对象不包含 <em>函数表达式(function expressions)</em> (与 <em>函数声明(function declarations) 比较</em>)。<br><br>变量对象是一个抽象的概念。在不同的上下文中，它以不同的对象[译注:意思应为对象集合]来表示。举例来说，全局上下文中，变量对象是 <em>全局对象本身(global object itself) </em>(这就是我们能够通过属性名称引用全局对象的全局变量)。<br><br>让我们看看下面的例子：<br><br>[code=’js’]<br>var foo = 10;<br><br>function bar() {} // 函数声明<br>(function baz() {}); // 函数表达式<br><br>console.log(<br>  this.foo == foo, // true<br>  window.bar == bar // true<br>);<br><br>console.log(baz); // 引用错误，baz没有被定义<br>[/code]<br><br>全局上下文中的变量对象(<abbr>VO</abbr>)会有如下属性：<br><br><img src="http://blog.meituo.net/wp-content/uploads/ecmascript_core/variable-object.png" alt="Figure 7\. The global variable object." title="Figure 7\. The global variable object."><br><br>图 7. 全局变量对象<br><br>如上所示，函数“baz”如果作为函数表达式则不被包含于变量对象。这就是在函数外部尝试访问产生 <em>引应用错误(ReferenceError)</em> 的原因。<br><br>请注意，ECMAScript和其他语言相比(比如C/C++)，仅有函数能够创建新的作用域。在函数内部定义的变量与内部函数，在外部非直接可见并且不污染全局对象。<br><br>使用 <em>eval</em> 的时候，我们同样会使用一个新的(eval创建)执行上下文。eval会使用全局变量对象或调用者的变量对象(eval的调用来源)。<br><br>那函数以及自身的变量对象又是怎样的呢?在一个函数上下文中，变量对象被表示为 <em>活动对象(activation object)</em>。<br><br>### <a id="activation-object">七、活动对象(Activation object)</a><br><br>当函数被调用者激活，一个特殊的对象&mdash;&mdash;<em>活动对象(activation object)</em> 将被创建。它包含 <em>形式参数(formal parameters)</em> 与特殊 <em>参数(arguments)</em> 对象(具有索引属性的形参键值表(map)[译注：表现为数组])。活动对象在函数上下文中作为变量对象使用。<br><br>即：函数的变量对象保持不变，但除去存储变量与函数声明之外，还包含形参以及特殊对象 <em>arguments </em>。<br><br>考虑下面的例子<br><br>[code=”js”]<br><br>function foo(x, y) {<br>  var z = 30;<br>  function bar() {} // FD<br>  (function baz() {}); // FE<br>}<br><br>foo(10, 20);<br>[/code]<br><br>“foo”函数上下文的下一个活动对象(<abbr>AO</abbr>)如下图所示：<br><br><img src="http://blog.meituo.net/wp-content/uploads/ecmascript_core/activation-object.png" alt="Figure 8\. An activation object." title="Figure 8\. An activation object."><br><br>图 8. 活动对象<br><br>由上可见<em>函数表达式</em>“baz”并未包含在变量/活动对象中。<br><br>对于这个话题的完整描述与所有巧妙示例(比如变量与函数声明的<em>“挂起(hoisting)”</em>)[译注：hoisting的语义需要推敲~~]可以在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="external">第2章. 可变对象</a>(<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="external">Chapter 2. Variable object</a>)找到。<br><br>让我们来看下一小节的内容。众所周知，在ECMAScript中我们可以使用内部函数，而在内部函数中，我们或许会引用父函数或全局上下文中的变量。如果我们将函数的 <em>变量对象</em> 命名为上下文的 <em>作用域对象(scope object)</em> ，那么和之前讨论的原型链类似，也有一个所谓的 <em>作用域链(scope chain) </em>。<br><br>### <a id="scope-chain">八、作用域链(Scope Chains)</a><br><br>&gt; 作用域链是一个 <em>对象列表(list of objects) ，</em>用以检索上下文代码中出现的 <em>标识符(identifiers) </em>。<br><br>作用域链规则简单并且与原型链相似：如果一个变量不是在自身的作用域内(自身 变量/活动 对象)，那么就会在它的外部作用域中查找。<br><br>考虑到上下文，标识符为:<em>变量名</em>，函数声明，形式参数等等。 在函数代码中，如果标识符不是一个本地变量/函数/形参，那么就被称之为<em> 自由变量(free variable) </em>。作用域链正是用于查找这些自由变量。<br><br>一般情况下，作用域链是 <em>父变量对象(parent variable objects) </em>列表外加(在作用域链头部)函数的 <em>自身变量/活动对象(own variable/activation object) </em>。然而作用域链也会包含其他对象，举例来说某些对象会在上下文的执行过程中，动态载入作用域链&mdash;&mdash;如 <em>with-objects</em> 或 <em>catch-clauses </em>创建的特殊对象。[译注：with-objects指的是with语句，产生的临时作用域对象；catch-clauses指的是catch从句，如catch(e)，这会产生异常对象，导致作用域变更]<br><br>当查找标识符的时候，会从作用域链的活动对象部分开始查找，然后(如果标识符没有在活动对象中找到)查找作用域链的顶部，循环往复，就像作用域链那样。<br><br>[code=’js’]<br>var x = 10;<br><br>(function foo() {<br>  var y = 20;<br>  (function bar() {<br>    var z = 30;<br>    // “x”和”y”是自由变量<br><br>    // 会在作用域链的下一个对象中找到(函数”bar”的互动对象之后)<br>    console.log(x + y + z);<br>  })();<br>})();<br>[/code]<br><br>我们可以通过隐含的<strong><em>parent</em></strong> 属性来设定作用域链的范围，<strong><em>parent</em></strong> 指向链表的下一个对象。这个尝试可以在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/#feature-of-implementations-property-__parent__" target="_blank" rel="external">真实的Rhino代码</a>(<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/#feature-of-implementations-property-__parent__" target="_blank" rel="external">real Rhino code</a>)中测试[译注:Rhino为Mozilla的开源项目，基于Java实现的ECMAScript引擎],并且是 <em>ES5词法环境(ES5 lexical environments)</em> 中实际使用的技术(被命名为outer的链接)。作用域链还可以通过数组展现。通过使用 <strong>parent</strong> 的概念，我们可以用下图展现上面的例子(父变量对象存储在函数的[[Scope]]属性内)：<br><br><img src="http://blog.meituo.net/wp-content/uploads/ecmascript_core/scope-chain.png" alt="Figure 9\. A scope chain." title="Figure 9\. A scope chain."><br><br>图 9. 作用域链<br><br>代码执行时，作用域链可能会被 <em>with语句(with-statement)</em> 和 <em>catch从句(catch-clause)</em> 对象扩大(增长)。此外，由于这些对象是简单对象，他们拥有原型(和原型链)。实际上作用域链表查找分为 <em>两个维度(two-dimensional) </em>：(1)首先考虑自身的作用域链表指针，(2)对于每一个作用域链表指针，需要深入到指针自身的原型链当中去(如果作用域链表的节点拥有原型)。<br><br>举例：<br><br>[code=’js’]<br><br>Object.prototype.x = 10;<br><br>var w = 20;<br>var y = 30;<br><br>// in SpiderMonkey global object<br>// i.e. variable object of the global<br>// context inherits from “Object.prototype”,<br>// so we may refer “not defined global<br>// variable x”, which is found in<br>// the prototype chain<br><br>console.log(x); // 10<br><br>(function foo() {<br><br>  // “foo” local variables<br>  var x = 100;<br>  var w = 40;<br><br>  // “x” is found in the<br>  // “Object.prototype”, because<br>  // {z: 50} inherits from it<br><br>  with ({z: 50}) {<br>    console.log(w, x, y , z); // 40, 10, 30, 50<br>  }<br><br>  // after “with” object is removed<br>  // from the scope chain, “x” is<br>  // again found in the AO of “foo” context;<br>  // variable “w” is also local<br>  console.log(x, w); // 100, 40<br><br>  // and that’s how we may refer<br>  // shadowed global “w” variable in<br>  // the browser host environment<br>  console.log(window.w); // 20<br><br>})();<br><br>[/code]<br><br>结构如下(这表明当我们进入 <strong>parent</strong> 指针之前, 第一个 <strong>proto</strong> 链会先背考虑)：<br><br><img src="http://blog.meituo.net/wp-content/uploads/ecmascript_core/scope-chain-with.png" alt="Figure 10\. A \" title="Figure 10\. A \"><br><br>图 10. with增大的作用域链<br><br>请注意，全局对象并非在所有实现中都会继承自“Object.prototype”。上图描述的情景(从全局上下文中引用了未定义的变量”x”)可以在SpiderMonkey测试。<br><br>只要所有外部函数的变量对象都存在，那么从内部函数引用外部数据则没有特别之处&mdash;&mdash;我们只要遍历作用域链表，查找所需变量。然而，如上文所提及，当一个上下文终止之后，其状态与自身将会被 <em>销毁(destroyed)</em> ，同时内部函数将会从外部函数中返回。此外，这个返回的函数之后可能会在其他的上下文中被激活，那么如果一个之前被终止的含有一些自由变量的上下文又被激活将会怎样?通常来说，解决这个问题的概念在ECMAScript中与作用域链直接相关，被称为 <em>(词法)闭包((lexical) closure)</em>。<br><br>### <a id="closures">九、闭包(Closures)</a><br><br>在ECMAScript中，函数是“第一类”对象。这个名词意味着函数可以作为参数被传递给其他函数使用 (在这种情况下，函数被称为<em>“funargs”&mdash;&mdash;</em>“functional arguments”的缩写[译注：这里不知翻译为泛函参数是否恰当])。接收“funargs”的函数被称之为 <em>高阶函数(higher-order functions)</em> ，或者更接近数学概念的话，被称为 <em>运算符(operators)</em> 。其他函数的运行时也会返回函数，这些返回的函数被称为 <em>function valued</em> 函数 (有 <em>functional value </em>的函数)。<br><br>“funargs”与“functional values”有两个概念上的问题，这两个子问题被称为<em>“Funarg problem”</em> (“泛函参数问题”)。要准确解决泛函参数问题，需要引入 <em>闭包(closures)</em> 到的概念。让我们仔细描述这两个问题(我们可以见到，在ECMAScript中使用了函数的[[Scope]]属性来解决这个问题)。<br><br>“funarg problem”的一个子问题是<em>“upward funarg problem”</em>[译注：或许可以翻译为：向上查找的函数参数问题]。当一个函数从其他函数返回到外部的时候，这个问题将会出现。要能够在外部上下文结束时，进入外部上下文的变量，内部函数 <em>在创建的时候(at creation moment)</em> 需要将之存储进[[Scope]]属性的父元素的作用域中。然后当函数被激活时，上下文的作用域链表现为活动对象与[[Scope]]属性的组合(事实上，可以在上图见到)：<br><br>&gt; 作用域链 = 活动对象 + [[Scope]]<br><br>请注意，最主要的事情是&mdash;&mdash;函数在被创建时保存外部作用域，是因为这个 <em>被保存的作用域链(saved scope chain)</em> 将会在未来的函数调用中用于变量查找。<br><br>[code=’js’]<br>function foo() {<br>  var x = 10;<br>  return function bar() {<br>    console.log(x);<br>  };<br>}<br><br>// “foo” returns also a function<br>// and this returned function uses<br>// free variable “x”<br><br>var returnedFunction = foo();<br><br>// global variable “x”<br>var x = 20;<br><br>// execution of the returned function<br>returnedFunction(); // 10, but not 20<br>[/code]<br><br>这种类型的作用域被称为 <em>静态作用域(static (or lexical) scope) </em>。可见变量“x”可以在函数”bar”返回的被保存的[[Scope]]中。通常来说，当上面代码中，变量”x”被设为20而不为10的时候还有一个 <em>动态作用域(dynamic scope)</em> 。 但是ECMAScript并未使用动态作用域。<br><br>“funarg problem”的第二个子问题是一个<em>“downward funarg problem” </em>[译注：或许可以翻译为：向内查找的函数参数问题]。在这个例子中，外部上下文可能存在，但是对于解析标识符会产生二义性。问题是：哪一个作用域中的标识符的值会被使用的呢&mdash;&mdash;是在函数创建时还是在函数执行时产生的作用域呢(比如调用者的作用域)?为了避免二义性与确立闭包，静态作用域会被使用：<br><br>我们可以做出总结： 静态作用域是在一种语言中使用闭包的 <em>必备需求(obligatory requirement) </em>。然而某些语言会同时提供静态作用域与动态作用域，以供程序员选择使用闭包。因ECMAScript中只有静态作用域被使用对于“funarg problem”的两个子问题，我们拥有解决方案)，结论如下：ECMAScript在技术上使用函数的[[Scope]]属性，从而对闭包有完整的支持。现在我们可以给闭包一个准确的定义：<br><br>&gt; 闭包由 代码块(ECMAScript中这是一个函数) 与 被静态/词法存储的所有外部作用域 组合而成。因此，函数可以通过被存储的作用域简单引用自由变量。<br><br>请注意，因为每一个(一般)函数在创建时保存了[[Scope]]，理论上，ECMAScript中所有函数都是闭包。<br><br>另一件重要的事情是，一些函数可能会有同样的外部作用域(当有两个内部/全局函数式，这是很常见的情况)。在这个例子中[[Scope]]属性是由所有拥有同样外部作用域的函数共享的。在某个闭包中产生的变量变化将会在其他闭包中读取变量时 <em>反映(reflected)</em> 出来：<br><br>[code=’js’]<br>function baz() {<br>  var x = 1;<br>  return {<br>    foo: function foo() { return ++x; },<br>    bar: function bar() { return –x; }<br>  };<br>}<br><br>var closures = baz();<br><br>console.log(<br>  closures.foo(), // 2<br>  closures.bar()  // 1<br>);<br>[/code]<br><br>代码如下图所示：<br><br><img src="http://blog.meituo.net/wp-content/uploads/ecmascript_core/shared-scope.png" alt="Figure 11\. A shared [[Scope]]." title="Figure 11\. A shared [[Scope]]."><br><br>图 11. 共享的[[Scope]].<br><br>在某个循环中创建多个函数时，上图会引发一个困惑。如果在创建的函数中使用循环变量(如”k”)，那么所有的函数都使用同样的循环变量，导致一些程序员经常会得不到预期值。现在清楚为什么会产生如此问题了&mdash;&mdash;因为所有函数共享同一个[[Scope]]，其中循环变量为最后一次复赋值。<br><br>[code=’js’]<br>var data = [];<br><br>for (var k = 0; k &lt; 3; k++) {<br>  data[k] = function () {<br>    alert(k);<br>  };<br>}<br><br>data<a href="">0</a>; // 3, but not 0<br>data<a href="">1</a>; // 3, but not 1<br>data<a href="">2</a>; // 3, but not 2<br>[/code]<br><br>有一些用以解决这类问题的技术。其中一种技巧是在作用域链中提供一个额外的对象，比如使用其他函数：<br>[code=’js’]<br>var data = [];<br><br>for (var k = 0; k &lt; 3; k++) {<br>  data[k] = (function (x) {<br>    return function () {<br>      alert(x);<br>    };<br>  })(k); // pass “k” value<br>}<br><br>// now it is correct<br>data<a href="">0</a>; // 0<br>data<a href="">1</a>; // 1<br>data<a href="">2</a>; // 2<br>[/code]<br><p>闭包理论的深入研究与具体实践可以在 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="external">第6章.闭包</a>(<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="external">Chapter 6. Closures</a>)中找到。如果想得到关于作用域链的更多信息，可以参照 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="external">第4章作用域链</a>(<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="external">Chapter 4. Scope chain</a>)。<br></p><p>下一章节将会讨论一个执行上下文的最后一个属性&mdash;&mdash;<em>this</em>指针的概念。<br><br>### <a id="this-value">十、This指针(This Value)</a><br><br>&gt; <em>this </em>指针是一个与执行上下文相关的特殊对象。因此，它也会被命名为 <em>上下文对象(context object)</em> (激活执行上下文的上下文)。<br><br>任何对象都可以作为上下文的this值。我想再次澄清对与ECMAScript中，与执行上下文相关的一些描述&mdash;&mdash;特别是this的误解。通常，<em>this </em>被错误地，描述为变量对象的属性。最近比如在<a href="http://yuiblog.com/assets/High_Perf_JavaScr_Ch2.pdf" target="_blank" rel="external">这本书中</a>就发现了(尽管书中提及this的那一章还不错)。 请牢记：<br><br><em>this </em>是执行上下文的属性，但不是变量对象的属性。<br><br>这个特征是很重要的。因为同变量比较，<em>this </em>从不参与变量解析的过程。即当在代码中访问<em>this</em>，它的值是从执行上下文中直接得到而不需要任何作用域链的查找。<em>this</em> 的值在进入上下文时即被确立。<br><br>和ECMAScript相比，Python有自己的 <em>self</em> 参数作为单独的变量用于解析同样问题。ECMAScript中，<em>this </em>不能被重新赋值，因为this不是一个变量，并且不属于变量对象。<br><br>在全局上下文中，<em>this 就是</em>全局对象本身(这意味着，this等于全局对象)：<br><br>[code=’js’]<br>var x = 10;<br><br>console.log(<br>  x, // 10<br>  this.x, // 10<br>  window.x // 10<br>);<br>[/code]<br><br>在函数上下文中，每一次单独的函数调用，<em>this </em>的值都不相同。这里this的值是由call函数表达式提供的调用者本身(函数被激活的一个方法)。举例来说，下面的函数“foo”被全局上下文调用，是一个被调用者。然我们看看这个例子，同样的函数代码对于不同的调用(使用不同的函数激活方式)，调用者提供的this值是怎样不同的：<br><br>[code=’js’]<br>// the code of the “foo” function<br>// never changes, but the “this” value<br>// differs in every activation<br><br>function foo() {<br>  alert(this);<br>}<br><br>// caller activates “foo” (callee) and<br>// provides “this” for the callee<br><br>foo(); // global object<br>foo.prototype.constructor(); // foo.prototype<br><br>var bar = {<br>  baz: foo<br>};<br><br>bar.baz(); // bar<br><br>(bar.baz)(); // also bar<br>(bar.baz = bar.baz)(); // but here is global object<br>(bar.baz, bar.baz)(); // also global object<br>(false || bar.baz)(); // also global object<br><br>var otherFoo = bar.baz;<br>otherFoo(); // again global object<br>[/code]<br><br>如果要深入思考每一次函数调用中，this值的变化(更重要的是怎样变化)，你可以阅读 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/" target="_blank" rel="external">第3章. This</a>(<a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/" target="_blank" rel="external">Chapter 3. This</a>) 。上文所提及的情况都会在第三章内详细讨论。<br><br>### <a id="conclusion">十一、总结(Conclusion)</a><br><br>在此我们完成了一个简短的概述。尽管看来不是那么简短，但是这些话题若要完整表述完毕，则需要一整本书。.我们没有提及两个重要话题：<em>泛函(functions)</em> (以及不同类型的函数之间的不同，比如函数声明与函数表达式)与ECMAScript的 <em>求值策略(evaluation strategy)</em> 。这两个话题可以分别查阅 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/" target="_blank" rel="external">第5章. 泛函</a>(<a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/" target="_blank" rel="external">Chapter 5. Functions</a>) 与 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/" target="_blank" rel="external">第8章. 求值策略(</a><a href="http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/" target="_blank" rel="external">Chapter 8. Evaluation strategy</a>)。<br><br>如果你有任何评论，问题或者补充，我很欢迎在文章评论中讨论。<br><br>祝大家学习ECMAScript顺利。<br><br><strong>原作者:</strong><a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/comment-page-1/#comment-3007" target="_blank" rel="external"> Dmitry A. Soshnikov</a><strong>发布于: </strong>2010-09-02<br><br></p></div>
      
    </div>
  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/JavaScript/">JavaScript</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/ECMA-262/">ECMA-262</a>
    </span>
    

    </div>

    
  </div>
</article>

  




    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2016 独孤逸辰
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>
